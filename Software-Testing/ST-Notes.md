# 软件测试笔记

评分：小测 2 * 5 分，作业 4 * 10 分，开卷期末 50 分

[Slides: Course slides in `./slides`]

[Book: 软件测试：一个软件工艺师的方法（第四版），机械工业出版社]

## 第一节 概论

- 软件测试的必要性和重要性
    - 基本事实：各种各样的软件已经到处都是
    - 软件错误会带来巨大的潜在损失（直接损失和发现错误后的修复成本等）
    - 即使是优秀的程序员，即使有很好的系统设计，在绝大多数情况下都不是error-free的
    - 如何保障软件质量：除了提高代码质量，改善软件工程方法之外，做软件测试已经成为了主要的软件质量保障方法
- 软件测试的目的
    - 功能正确
    - 了解性能
    - 测试安全性
    - 测试易用性
    - 在完成以上几项的基础上尽量减小测试开销
- 基本概念
    - 测试用例（test case）：包含输入和期望输出
    - 错误（error）：底层的编程错误，错误很容易传播（propagate）
    - 故障（fault）：错误的具体表现，故障不一定是由编程错误引入的，也有可能是物理设备故障，系统设计错误和用户交互错误
    - 失效（failure）：代码运行时发生故障的后果，错误转为失效需要满足RIPR模型
        - 用状态图分析程序，当执行过一个故障时，程序的状态与期望的程序状态将出现差异
        - Reachability - 故障是可达的
        - Infection - 故障会导致代码状态出错
        - Propagation - 错误的状态会导致代码的最终状态或输出出错
        - Revealability - 最终状态错误或输出错误必须是可观察的
        - 可以用RIPR模型帮助设计测试用例
    - 事故（incident）：用户能够明确发现的失效
- 基本原则 [[Link]](https://www.cnblogs.com/goloving/p/15172497.html)
    - Myers准则
        - 在软件开发的早期就开始测试，并持续测试
        - 避免开发者测试自己的软件
        - 测试用例不仅要包含输入，还要包含期望输出
        - 测试用例需要包涵有效输入和无效输入
        - 测试用例需要覆盖“软件该做什么”和“软件不该做什么”
        - 测试发现的错误和实际存在的错误的量成正比
        - 应当进行多轮反复测试
        - 软件测试是创新性的工作！
    - 独立性准则（第三方测试）
    - 完备性准则
        - 完成测试计划
        - 达成一定的覆盖率指标
- 基本过程
    - 设计测试计划
    - 生成测试用例 [[Link]](https://www.cnblogs.com/goloving/p/15173334.html)
    - 搭建测试环境
    - 执行测试用例
    - 评估测试结果
- 一些其他事实
    - 可能的输入集合（在大部分情况下）是难以遍历的甚至无法遍历的，软件测试需要选出一些有价值的输入输出作为测试用例
    - 软件测试的开销是不可忽略的（事实上甚至往往超过软件总开发成本的一半！），软件测试工程常常要在测试开销和测试效果（测试覆盖率）之间做trade-off
    - 软件测试不能保证软件是error-free的，需要证明error-free请转隔壁形式化验证

## 第二节 数学基础

[出门转隔壁离散数学]

## 第三节 基本理论和基本方法

[Slides Ch3 P3]

- 静态测试
    - Code Review
    - 代码分析
    - 走查和审查
- 动态测试
    - 黑盒测试：针对需求规格说明进行检验
        - 边界值测试
        - 等价类测试
        - 决策表测试
    - 白盒测试：针对代码进行检验，路径导向
        - 路径测试
            - 语句覆盖
            - 路径覆盖
            - 判断覆盖
        - 数据流测试
- 形式化验证（开销极大，用于需要保证程序完全安全，error-free的场景，几乎不可能广泛使用）
- 其他测试方法 [Slides Ch3 P32 - P41]
    - 变异测试
    - 回归测试
    - 故障统计与可靠性分析
    - 净室法

## 第四节 测试环境和测试工具

- Java
    - JRE & JDK
    - 良好的测试环境和工具支持
- JUnit 回归测试框架
    - 适合于极限编程方法
    - Eclipse/Idea 对 JUnit 有良好的集成支持
    - 测试用注解 [Slides Ch4 P10]
    - JUnit 框架的测试流程
        - `setUp()` 创建测试实例
        - `testMethod()` 执行测试方法
        - `tearDown()` 回收实例资源
        - 注意：多个测试方法不应相互依赖（因为它们都在独立的实例中被测试）
- EMMA 覆盖率分析工具
- IntelliJ Idea
    - 丰富的内置工具和插件
    - 如何正确的代码结构与目录管理：将测试代码与主程序放置在不同的根目录下
    - 测试类的代码生成
    - 自动化生成测试报告
- 参数化测试工具：将测试用例与测试代码分离，简化多测试用例对应的代码
    - 工具：JUnit4/JUnit5/TestNG
- 打桩 (Mock) 测试：模拟对其他模块的调用，提高覆盖率，方便故障定位，去除模块间依赖
    - 工具：Mockito/PowerMock
- 变异测试：评估一组测试用例的完备性
    - 工具：Pitest
- 完善的测试文档案例 [Slides Ch4 P49 - P62] [Book Appendix]

## 第五节 功能性测试（黑盒测试）

- 目的
    - 按需求规格说明书对软件的外部特征进行测试，确认系统的功能是否正确实现
- 软件缺陷的基本假设
    - 单缺陷假设：失效很少是由两个或更多缺陷同时发生引起的
    - 多缺陷假设（“最坏情况”）：拒绝单缺陷假设，认为失效可能是由两个或更多缺陷同时发生引起的
    - 健壮性：考虑无效输入
- 边界值测试
    - 基本事实：很多函数更倾向于在边界值附近出错
    - 对一个有 n 个参数（即 n 个输入维度）的函数：
    - 划分出有效输入区域（一个 n 维空间）（为了讨论方便，假设每个输入维度上只有一个连续的有效输入区间）[Book Ch10 P133]
    - 边界值测试的几种类型：
        - 一般边界值测试：测试用例为保持其他维度取随机有效中间值，某一维度取最小值，略高于最小值，最大值，略低于最大值（对每个输入维度都要测试），再加上一个所有输入维度都取中间值的用例，共 4n + 1 个
        - 健壮性测试：测试用例在一般边界值测试的基础上对每个输入维度追加略低于最小值和略高于最大值的两个无效输入，将测试用例增加到 6n + 1 个
        - 最坏情况测试：拒绝单缺陷假设，考虑每一个输入维度的五种输入（最小值，略高于最小值，最大值，略低于最大值，中间值）的自由组合，测试用例数量共 $5^n$ 个
        - 健壮最坏情况测试：在最坏情况测试的基础上考虑每个输入维度的略低于最小值和略高于最大值的两个无效输入，将测试用例增加到 $7^n$ 个
    - 一般边界值测试和健壮性测试的开销对输入维度数量是线性的，最坏情况测试的开销对输入维度数量是指数的
- 随机测试
    - 随机取出测试用例，直到满足一定的测试需求再停止（例如每类输出至少有一个，或每类输入至少有5个等）
- 特殊值测试
    - 直接凭借测试者的背景知识产生“可能”揭示故障的测试用例
- 等价类测试
    - 对一个有 n 个参数（即 n 个输入维度）的函数：
    - 按一定标准生成每个输入维度的一个划分（一组并是全集的不相交集），即等价区间
    - 不妨假设第 i 个输入维度的等价区间数量为 $m_i$
    - 等价类测试的几种类型：
        - 弱一般等价类测试：取等同于等价区间数量最多的输入维度的等价区间数量的测试用例数量，即 $max(m_i)$ 个 ，保证每一个输入维度的每一个等价区间都被取到至少一次（输入在等价区间内的取值是随机的），这种方法对错误定位存在局限性
        - 强一般等价类测试：拒绝单缺陷假设，覆盖所有的等价区间组合，测试用例共 $\prod m_i$ 个
        - 弱健壮等价类测试：对每个输入维度考虑无效输入的等价区间，不妨假设第 i 个输入维度的无效输入等价区间数量为 $p_i$ 个（一般若无特殊说明则认为 $p_i = 2$ ，则取 $[max(m_i + p_i), max(m_i) + \sum p_i]$ 个测试用例（“弱健壮等价类测试”～“改进弱健壮等价类测试”），取法同弱一般等价类测试
        - 强健壮等价类测试：覆盖所有包含无效输入的等价区间组合，将测试用例增加到 $\prod (m_i + p_i)$ 个
    - 等价区间的划分不一定要有实际的应用场景意义，也可以直接按照输出类型划分或者人为划分输入区间
    - 对于一些因为变量之间存在依赖关系导致有效输入区域并不是一个各条棱相互正交的高维空间的软件，等价类测试可能会产生无效的甚至错误的测试用例
- 边界值测试与等价类测试的缝合怪：边缘测试
- 决策表测试
    - 适用于业务流复杂的软件
    - 提炼软件输入和输出的逻辑规则，对每一个条件组合（“规则”）做一个测试用例
    - 合并同类项，提取等价类，逐级分解决策表，改善条件表项设置，减少用例数量（这样做不会导致测试完备性损失！）
- 测试方法的选用原则 [Slides Ch5 P39]

## 第六节 第七节 结构化测试（白盒测试）

- 目的
    - 根据程序内部的逻辑结构验证软件的结构是否正确，要求实现较高的覆盖率
    - 单元测试大多采用白盒测试，系统测试大多采用黑盒测试
    - 白盒测试相比于黑盒测试善于发现内存泄漏，误差累积等系统内的隐患性的深层故障
- 代码逻辑的形式化
    - 程序图
        - 节点：不含分支和循环的代码片
        - 有向边：代码片执行的拓扑关系（控制流）
        - 缺陷：不同的代码分片粒度可能会导致一段代码可以产生多种程序图
    - DD (Decision-to-Decision) -路径图：程序图的唯一压缩图
        - DD-路径：程序图内的最小独立路径，互不包含
            - 源点 (入度 == 0)
            - 汇点 (出度 == 0)
            - 分支结点/汇合结点 (入度 >= 2 ^ 出度 >= 2)
            - 一个 (入度 == 1 && 出度 == 1) 的结点
            - 一串（ >= 2个） (入度 == 1 && 出度 == 1) 的结点构成的最大链
        - 节点：DD-路径
        - 边：DD-路径执行的拓扑关系（控制流）
- 路径测试：关注程序结构但不关心数据
    - 相关的测试覆盖指标
        - $C_0$：语句覆盖（DD-路径图的结点覆盖），测试用例集使得所有语句至少执行一次
        - $C_1$：分支覆盖（DD-路径图的边覆盖），使得每个判断表达式的真假各至少取到一次，且每个分支表达式的所有情况被遍历
        - $C_{1p}$：条件覆盖，使得每个判断表达式中的每个子句（谓词）的真假各至少取到一次（不能保证判断表达式的真假各取到一次！），且每个分支表达式的所有情况被遍历
        - $C_{mcc}$：多重条件覆盖（组合覆盖），使得每个判断表达式中的所有可能子句取值组合被遍历
        - $C_{\infty}$：路径覆盖，遍历所有可能的执行路径
        - $C_{ik}$：k-循环覆盖，覆盖包含至多 k 次循环的所有程序路径
        - $C_2$： $C_1$ 覆盖+ $C_{i1}$ 覆盖
        - 分支-条件覆盖：分支覆盖和条件覆盖的缝合怪，开销比 $C_{mcc}$ 低
    - 循环测试的方法（假设循环执行 N 次）
        - 单循环测试：执行循环体 0, 1, 2, 某一中间值, N-1, N, N+1 次（类似于健壮边界值测试）
        - 嵌套循环测试：由内到外按单循环测试，测试某一层时其他层次循环次数为1
        - 级联循环测试：逐个按单循环测试
        - 不规则循环测试：不测，测不了，打回去重构（现实中这种情况可能由于不当使用 try - catch 语句等原因产生）
    - McCabe的基路径（基本路径）方法
        - McCabe基路径，圈复杂度，McCabe圈数 [概念转隔壁离散数学]
        - 圈复杂度类似于DD-路径图的“秩”
        - 圈复杂度主要用于衡量和帮助控制软件的复杂度
        - 基本路径类似于向量空间中的基向量
        - 找到所有的基本路径，只需测试所有基本路径便可以认为所有可能的执行路径都已被覆盖（因为它们都是基本路径的线性表示！）
        - 但是这种图论分析不考虑程序的语义（线性表示的拓扑语义是模糊的），计算得到的基本路径实际上可能是不可达的
- 数据流测试
    - 通过编译器静态排查简单的故障
    - 定义-使用 (def-use) 测试
        - 定义节点，使用节点，谓词使用和计算使用
        - 定义使用路径 (du-path) 和定义清除路径 (dc-path)
        - 相关的测试覆盖指标（假设所有拓扑路径都是可达的）
            - 全节点覆盖，全边覆盖，全路径覆盖：同语句覆盖，分支覆盖，路径覆盖
            - 全定义覆盖：覆盖每个定义节点到一个使用节点的定义清除路径
            - 全谓词使用/部分计算使用：覆盖每个定义节点到所有谓词使用（如无，则改为到一个计算使用）的定义清除路径
            - 全计算使用/部分谓词使用：覆盖每个定义节点到所有计算使用（如无，则改为到一个谓词使用）的定义清除路径
            - 全使用覆盖：每个定义节点到所有使用节点及其后续节点的定义清除路径
            - 全定义-使用路径覆盖：覆盖每个定义节点到所有使用节点及其后续节点的定义清除路径，如果包含循环，测试不循环和循环一次这两种情况
        - 关注数据使用的正确性，但忽视了数据间的依赖关系
- 程序片测试
    - 程序中某个变量集合的程序片是对这些变量值“有贡献”（不仅是直接的定义，还可以是因谓词使用等因素对当前关注的变量值产生影响）的所有语句（静态后向切片）的集合
    - 程序切片的前向，后向，静态，动态 [Book Ch9 P116] [[Link]](https://blog.csdn.net/hmysn/article/details/124717162#t6)
    - 每次测试某一个变量集合的切片是否正确（如果这个变量集合的所有子集（包含本身）的程序片测试结果都是正确的，就认为这个变量集合的切片是正确的），如果所有变量（变量的全集）的定义和使用都是正确的就可以认为程序整体是正确的
    - 能够细致地反应数据间的依赖关系
    - 能够比较便捷地定位错误（通过不同程序片的对比快速找出错误位置）

- 单元测试的总结
    - 何时结束测试？ [Slides Ch7 P57] [Book Ch10 P126]
    - 测试方法的取舍：trade-off
    - 对测试的评估：漏洞与冗余
        - 量化指标：假设执行方法 M 生成的 m 个测试用例时经过了测试指标 S 所指出的 s 个结构性测试单元中的 n 个，则：
            - M关于S的覆盖 $C (M, S) = \dfrac{n}{s}$
            - M关于S的冗余 $R (M, S) = \dfrac{m}{s}$
            - M关于S的净冗余 $NR (M, S) = \dfrac{m}{n}$
    - 测试的指导方针 [Βοοk Ch10 P138]

## 小测（25分钟/5道简答题，范围到路径测试）

## 第八节（一） 基于生命周期的测试

- 一个问题：如何从单元测试拓展到对整个软件的测试？
    - “王源”（传统）的观点：瀑布式生命周期管理
        - 虽然有些古老，但也不失可取之处：便于管理，分工明确，便于并行工作
        - 存在的问题：不够灵活，要求开发者对整个系统的完整理解，软件工程风险全部落在最后阶段
        - 瀑布模型的变体
            - 增量开发模型：多次提交，不断追加功能，但需要预留一个开放的软件体系结构以便追加功能
            - 演化开发（快速原型）模型：反复提供原型软件，有助于明确客户需求，但设计大量原型比较困难（一般是利用现有的软件原型）
            - 螺旋模型：在瀑布模型的基础上对每个阶段都增加风险分析与验证的步骤，可以保证项目的可控性，但对软件风险评估提出了更高的要求
            - 核心思想是强调迭代与集成而非功能分解，从而将软件工程风险分散到软件工程过程中以便进行风险控制
            - 适合使用回归测试
        - 软件测试的 V-层次模型
            - 单元测试：面向详细设计的对软件独立模块的测试
            - 集成测试：面向概要设计的对软件模块之间的组合的测试
            - 系统测试：面向需求分析的对系统功能的测试
    - “顶针”（现代）的观点：敏捷开发
        - 敏捷宣言：核心是以人为本，适应变化
            - 个体和交互胜过过程和工具
            - 可用的软件胜过完备的文档（但是不能0文档！）
            - 客户协作胜过合同谈判
            - 响应变化胜过遵循计划
        - 一个很大的范畴
            - Scrum [Slides Ch8-1 P14]
                - 测试位于每次冲刺后
            - 极限编程 (XP) [Slides Ch8-1 P15 - P34]
                - 每次迭代都有测试
                - 测试驱动 (TDD)
                - 适应性软件开发
                - 结对编程
                - 持续集成等
        - 前沿探索：对敏捷开发过程中缺乏高层次设计的补偿——敏捷模型驱动开发 (AMDD) 与模型驱动的敏捷开发 (MDAD) [Book Ch11 P150]
    - 自动化测试简介
        - 为什么需要自动化：软件体量增加，更新频繁，测试需求随之增加，手工测试无法满足测试需求
        - 自动化测试框架的功能分解：
          - 测试用例生成
          - 脚本生成
          - 业务流定义
          - 数据配置
          - 测试调度

## 第八节（二） 集成测试与系统测试

- 明确集成测试和系统测试的区别
    - 集成测试主要由开发人员完成，测试的是通过单元测试的模块间的关系是否正确，面向的是概要设计文档，需要了解程序结构，是一种白盒测试，需要考虑路径覆盖
    - 系统测试需要客户参与，测试的是整个系统的功能是否正确，面向的是需求规格说明书，无需了解程序结构，是一种黑盒测试，需要考虑功能覆盖
- 集成测试的方法 [[Link]](https://blog.csdn.net/qq_41890041/article/details/109730310) [[Another Link]](https://blog.csdn.net/qq_19448047/article/details/106679185)
    - 原始的方法（基于功能分解树的集成）
        - 自顶向下集成：从主程序开始以 BFS 方式用桩程序模拟对下层节点调用的返回值，测试完上层节点的正确性后再用一个真实的下层节点替换桩程序继续测试
        - 自底向上集成：从叶子节点开始以 BFS 方式用驱动器程序模拟上层节点对下层节点的调用，保证一个节点所有的孩子测试完毕后再测试它本身，直到主程序被测试
        - 大爆炸集成：又称一次性集成，直接编译测试所有单元，但是无法定位故障的具体位置
        - 三明治集成：每次测试从根节点到某一些叶子节点的全路径（也可以理解为以 DFS 方式遍历功能树），是大爆炸集成和自顶向下（或者自底向上）集成在测试效率和效果上的折中，不需要任何桩或者驱动器程序
        - 优劣势：测试语义清晰，故障定位方便（不会真的有人会用大爆炸集成吧？），但是工作量极大，且可能会产生一些实际上不可能存在的待测接口（接口错误）
    - 基于调用图的集成
        - 在调用图中，将模块视为节点，将模块间的调用关系视为从调用者指向被调用者的有向边，以此规避基于功能分解树的集成的接口错误问题
        - 传统的几种集成策略也可以在调用图中取得比在功能树分解中更好的表现
        - 成对集成：对调用图中的每条边进行一次集成（创建一个集成会话）
        - 相邻集成：依次以调用图中的所有非叶子节点为“中心”，取其所有前驱节点和后继节点作为一个相邻单元进行集成
        - 优劣势：工具适配好，无需开发桩和驱动器程序减少了工作量，但是故障定位变得更为复杂，且每次修改代码后需要重新执行的测试量大大增加
    - 基于路径的集成
        - 模块执行路径与消息：
            - 源节点：程序开始执行或重新开始执行处的语句片段，即控制流交给本模块时执行的第一段代码
            - 汇节点：程序执行结束处的语句片段，即控制流跳出本模块（或结束）前执行的最后一段代码
            - 模块执行路径：以源节点开始，汇节点结束，且中间没有其他汇节点的程序执行路径，即“程序在本模块内执行的路径”
            - 消息：（跨模块）控制流转移的机制，在不同的语言中可能是过程调用等各种表现形式，有时需要为了表达清晰，把消息（调用消息）和返回消息作显式的区分
        - MM (Module to Module)-路径：模块执行路径和消息交替出现的序列
        - MM-路径图
            - 节点：模块执行路径
            - 有向边：消息和返回消息
            - MM-路径图的复杂度度量：同 McCabe 圈数的计算，MM-路径图中的双向箭头应被视为两条方向相反的有向边
        - 优劣势：结合了集成测试和系统测试，实际语义强，适用面广，但标识 MM-路径较为复杂
    - 三种集成测试方法的对比 [Slides Ch8-2 P15]
- 系统测试的方法
  - 系统功能的描述：系统从输入到输出的行为，即线索（thread）
    - 软件中存在各种粒度的线索，例如 DD-路径是单元级线索，MM-路径是集成级线索
    - 系统级的线索是原子系统功能（ASF）序列
      - ASF 是系统功能的最小单元，通过事件静止点划分
      - ASF 的划分具有主观性，它代表的是期望的系统测试与集成测试粒度的界线，ASF 在两个粒度上都可以测试，它是集成测试的最大测试项和系统测试的最小测试项，不会在大于 ASF 的单元上进行集成测试，也不会在小于 ASF 的单元上进行系统测试
      - 系统的 ASF 图是节点表示 ASF，边表示序列流的有向图，它具有源点和汇点
      - 系统级别的线索就是源 ASF 到汇 ASF 的路径
    - 常见的系统级线索
      - 基于模型的线索
        - 尝试构造系统功能的有限状态机模型，再通过模型产生所有可能的系统级线索

TODO: 这部分讲得有点乱，看完书回来继续补全

## 第九节 回归测试

- 概念
  - 软件工程过程的广泛应用使得软件不断变动成为常态
  - 但是只要软件发生了改变，就可能出现问题
    - 可能是对问题的修改被遗漏
    - 可能是所做的修改仅仅修正了错误的外在表现
    - 可能是新的内容导致了违背修改的部分产生新的问题
  - 回归测试就是为了在软件工程的过程中，在软件的生命周期中，验证软件的正确性
- 策略 [[Link]](https://blog.csdn.net/u014578266/article/details/89072365)
  - 设想这样一个软件工程过程：
    - V1：
      - 开发软件 P
      - 测试 P
      - 发布 P
    - V2：
      - 在P的基础上开发 P'
      - 测试 P' 相比于 P 的新功能
      - 测试 P' 从 P 继承而来的旧功能
      - 发布 P'
    - 回归测试就是 V2 过程中的两步测试步骤
  - 项目组需要维护一个测试用例库，并随着项目进程删除过时的用例，改进不受控的用例，删除冗余的用例（通过这三者可以形成新的基线测试用例库），并添加新的用例
  - 基线测试用例库：基于软件的某个基线版本的测试用例库
  - 执行回归测试即维护新的测试用例库并用新的测试用例库测试软件
  - 一个自然的想法：从上版本的测试用例集中选一部分测试，使得如果这个测试用例子集的运行没有出现问题，则可以认为新的软件版本中从旧版本继承的功能都是正确的
    - 测试用例子集怎么选择？
      - 一些自然的想法：
        - 再测试全部用例（即上述策略1）
          - 最完备但是开销太大
        - 基于风险选择测试用例
        - 基于操作剖面选择测试用例
        - 再测试修改的部分
          - 如果测试者对本项目有充足的了解则可以考虑使用
          - 通过等价性分析直接分析修改的影响并划定回归测试范围
      - 基于测试向量的回归测试用例选择策略
        - 对于所有的老版本测试用例，标识它们的执行路径
        - 对于老版本软件控制流图中的每一个节点，标识它们的测试向量（即哪些用例的执行流经过了这个节点）
        - 对新老版本软件，构建它们控制流图中的每个节点的语法树，并对照它们的区别
        - 选择所有新老语法树不等价的节点的测试向量对应的所有测试用例
        - 遇到较为复杂的实际软件时完备性和效率会打折扣
      - 基于测试最小化（测试实体的最小覆盖）的回归测试用例选择策略
        - 确认测试实体类型（函数，定义-使用路径，语句等）
        - 对所有的老版本测试用例，标识它们对这些测试实体的覆盖情况
        - 通过最小覆盖问题选出一个测试用例集合，使得所有的测试实体都被至少覆盖一次
        - 集合的最小覆盖问题是 NP 完全问题！
      - 基于测试优先级的回归测试用例选择策略
        - 对所有的老版本测试用例，标识它们对所有测试实体的覆盖情况
        - 按照单个用例的测试实体覆盖率对测试用例赋予优先级（当然，按风险或者按别的什么规则排序也是可以的）
        - 对新版本软件进行测试时以优先级为参照谨慎地（综合考虑测试代价和完备性等因素）弃用一些测试用例
  - 一些自动化回归测试框架 [Slides Ch9 P39]

## 小测（25分钟/5道简答题，范围到集成测试）

## 第十节 Web应用测试方法和工具

## 第十一节 变异测试

- 变异测试是用于检验一组测试用例是否完备的手段，一般推荐在单元测试粒度上应用，但如果有合适的工具和框架支持也可以用于更粗的粒度
  - 程序变异的概念
    - 假设原程序为 P，变异程序为 P'
    - 对于 T 中的测试用例 t，如果 P(t) != P'(t)，则认为 t 能将 P 与 P' 分辨出来，或者说 t 杀死了 P'
    - 相应地，如果对于 T 中的任意一个元素 t，都有 P(t) == P'(t)，则认为 P' 在 T 的测试过程中存活
    - 如果变异程序 P' 与原程序 P 语义不等价，但 P' 在 T 的测试过程中存活，则认为 T 是不完备的
    - 变异测试可以暴露测试集的问题，并为测试者提供改进测试集的机会
  - 变异测试的基本步骤 [Slides Ch11 P9-11]
    - 对原程序生成一系列变异体 $M = \{m_1,m_2,...,m_k\}$
      - 如何生成变异体？
        - 由于大多数时候程序中的错误都仅仅是一些简单错误（即“称职程序员假设”，程序员写出的程序即使存在错误也仅仅是与正确代码相差若干个突变），而且由多处变异产生的复合变异体一般都能被能够辨识其中一处变异的测试样例识别，再出于测试代价的考量，一般只会生成一阶变异体（即只进行一处变异）
        - 突变算子：用于生成突变体，一般会对简单错误进行模仿，例如替换一些变量和运算符，改变边界检查条件等
          - 突变算子的定义是高度主观的，它会受到被测程序的语言，开发团队和测试团队的代码规范等因素的影响
    - 在所有变异体上执行待评估的测试集
    - 如果所有的变异体都被辨识了，就认为 T 对于变异集 M 是完备的
    - 否则，计算变异系数 $m_s = \dfrac{被杀死的变异体数量}{非等价变异体数量}$
    - 如果出现了未被分辨的非等价变异体（ $m_s \ne 1$ ），则需要向原测试集中补充更多的用例，直到这些非等价变异体都能被分辨
      - 如何补充新的用例 t？
        - t 的执行流需要覆盖变异语句 s
        - 在执行完 P 和 m 的语句s后，程序的状态应该不一致
        - 这个不一致应该能传播到输出结果上
    - 但是验证一个程序的变异体与原程序是否等价是不可判定的！
      - 经验认为大约 5% 的变异体与原程序等价
      - 如果要精确地验证非等价变异体数量，那就只能手动标识了
- 补充：故障注入 [Book Ch21 P297]
  - 通过人为注入一系列已知故障并评估现有测试集找出这些故障的能力来评估测试集的方法
  - 如果注入的故障都被找到了，可以认为现有测试集相对于这组故障是完备的
  - 但如果只有一部分故障被找到，那就需要认为“野生的”故障也只有相应的比例被发现

## 第十二节 嵌入式系统测试（这部分过得很快且内容简单，直接看PPT就行） [Slides Ch12]

- 嵌入式系统是时间敏感的
  - 硬实时系统与软实时系统
  - 实时系统中的时间指标：最好情况执行时间 BCET，最坏情况执行时间 WCET，典型执行时间 TET，其中 WCET 一般是最重要的指标
    - WCET 如何测量？需要综合考量影响程序执行时间的因素
- 嵌入式系统测试的方法
  - 关注全数字模拟测试，交叉测试，真实环境验证三种方法
