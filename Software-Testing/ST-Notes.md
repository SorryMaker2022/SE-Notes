# 软件测试笔记

## 第一节 概论

- 软件测试的必要性和重要性
    - 基本事实：各种各样的软件已经到处都是
    - 软件错误会带来巨大的潜在损失（直接损失和发现错误后的修复成本等）
    - 即使是优秀的程序员，即使有很好的系统设计，在绝大多数情况下都不是error-free的
    - 如何保障软件质量：除了提高代码质量，改善软件工程方法之外，做软件测试已经成为了主要的软件质量保障方法
- 软件测试的目的
    - 功能正确
    - 了解性能
    - 测试安全性
    - 测试易用性
    - 在完成以上几项的基础上尽量减小测试开销
- 基本概念
    - 测试用例（test case）：包含输入和期望输出
    - 错误（error）：底层的编程错误，错误很容易传播（propagate）
    - 故障（fault）：错误的具体表现，故障不一定是由编程错误引入的，也有可能是物理设备故障，系统设计错误和用户交互错误
    - 失效（failure）：代码运行时发生故障的后果，错误转为失效需要满足RIPR模型
        - 用状态图分析程序，当执行过一个故障时，程序的状态与期望的程序状态将出现差异
        - Reachability - 故障是可达的
        - Infection - 故障会导致代码状态出错
        - Propagation - 错误的状态会导致代码的最终状态或输出出错
        - Revealability - 最终状态错误或输出错误必须是可观察的
        - 可以用RIPR模型帮助设计测试用例
    - 事故（incident）：用户能够明确发现的失效
- 基本原则
    - Myers准则
        - 在软件开发的早期就开始测试，并持续测试
        - 避免开发者测试自己的软件
        - 测试用例不仅要包含输入，还要包含期望输出
        - 测试用例需要包涵有效输入和无效输入
        - 测试用例需要覆盖“软件该做什么”和“软件不该做什么”
        - 测试发现的错误和实际存在的错误的量成正比
        - 应当进行多轮反复测试
        - 软件测试是创新性的工作！
    - 独立性准则（第三方测试）
    - 完备性准则
        - 完成测试计划
        - 达成一定的覆盖率指标
- 基本过程
    - 设计测试计划
    - 生成测试用例
    - 搭建测试环境
    - 执行测试用例
    - 评估测试结果
- 一些其他事实
    - 可能的输入集合（在大部分情况下）是难以遍历的甚至无法遍历的，软件测试需要选出一些有价值的输入输出作为测试用例
    - 软件测试的开销是不可忽略的（事实上甚至往往超过软件总开发成本的一半！），软件测试工程常常要在测试开销和测试效果（测试覆盖率）之间做trade-off
    - 软件测试不能保证软件是error-free的，需要证明error-free请转隔壁形式化验证

## 第二节 数学基础

出门转隔壁离散数学

## 第三节 基本理论和基本方法

[PPT Ch3 P3]

- 静态测试
    - Code Review
    - 代码分析
    - 走查和审查
- 动态测试
    - 黑盒测试：针对需求规格说明进行检验
        - 边界值测试
        - 等价类测试
        - 决策表测试
    - 白盒测试：针对代码进行检验，路径导向
        - 路径测试
            - 语句覆盖
            - 路径覆盖
            - 判断覆盖
        - 数据流测试
- 形式化验证（开销极大，用于需要保证程序完全安全，error-free的场景，几乎不可能广泛使用）
- 其他测试方法 [PPT Ch3 P32 - P41]
    - 变异测试
    - 回归测试
    - 故障统计（标志重捕法）与可靠性分析
    - 净室法

## 第四节 测试环境和测试工具

TODO

## 第五节 功能性测试（黑盒测试）

- 目的
    - 按需求规格说明书对软件的外部特征进行测试，确认系统的功能是否正确实现
- 软件缺陷的基本假设
    - 单缺陷假设：失效很少是由两个或更多缺陷同时发生引起的
    - 多缺陷假设（“最坏情况”）：拒绝单缺陷假设，认为失效可能是由两个或更多缺陷同时发生引起的
    - 健壮性：考虑无效输入
- 边界值测试
    - 基本事实：很多函数更倾向于在边界值附近出错
    - 对一个有 `n` 个参数（即 `n` 个输入维度）的函数：
    - 划分出有效输入区域（一个 `n` 维空间）（为了讨论方便，假设每个输入维度上只有一个连续的有效输入区间）
    - 边界值测试的几种类型：
        - 一般边界值测试：测试用例为保持其他维度取随机有效中间值，某一维度取最小值，略高于最小值，最大值，略低于最大值（对每个输入维度都要测试），再加上一个所有输入维度都取中间值的用例，共 `4n + 1` 个
        - 健壮性测试：测试用例在一般边界值测试的基础上对每个输入维度追加略低于最小值和略高于最大值的两个无效输入，将测试用例增加到 `6n + 1` 个
        - 最坏情况测试：拒绝单缺陷假设，考虑每一个输入维度的五种输入（最小值，略高于最小值，最大值，略低于最大值，中间值）的自由组合，测试用例数量共 $ 5 ^ n $ 个
        - 健壮最坏情况测试：在最坏情况测试的基础上考虑每个输入维度的略低于最小值和略高于最大值的两个无效输入，将测试用例增加到 $ 7 ^ n $ 个
    - 一般边界值测试和健壮性测试的开销对输入维度数量是线性的，最坏情况测试的开销对输入维度数量是指数的
- 随机测试
    - 随机取出测试用例，直到满足一定的测试需求再停止（例如每类输出至少有一个，或每类输入至少有5个等）
- 特殊值测试
    - 直接凭借测试者的背景知识产生“可能”揭示故障的测试用例
- 等价类测试
    - 对一个有 `n` 个参数（即 `n` 个输入维度）的函数：
    - 按一定标准生成每个输入维度的一个划分（一组并是全集的不相交集），即等价区间
    - 不妨假设第 `i` 个输入维度的等价区间数量为 $ m_i $
    - 等价类测试的几种类型：
        - 弱一般等价类测试：取等同于等价区间数量最多的输入维度的等价区间数量的测试用例数量，即 $ max(m_i) $ 个 ，保证每一个输入维度的每一个等价区间都被取到至少一次（输入在等价区间内的取值是随机的），这种方法对错误定位存在局限性
        - 强一般等价类测试：拒绝单缺陷假设，覆盖所有的等价区间组合，测试用例共 $ \prod m_i $ 个
        - 弱健壮等价类测试：对每个输入维度考虑无效输入的等价区间，不妨假设第 `i` 个输入维度的无效输入等价区间数量为 $ p_i $ 个（一般若无特殊说明则认为 $ p_i = 2 $ ，则取 $ [max(m_i + p_i), max(m_i) + \sum p_i] $ 个测试用例（“弱健壮等价类测试”～“改进弱健壮等价类测试”），取法同弱一般等价类测试
        - 强健壮等价类测试：覆盖所有包含无效输入的等价区间组合，将测试用例增加到 $ \prod (m_i + p_i) $ 个
    - 等价区间的划分不一定要有实际的应用场景意义，也可以直接按照输出类型划分或者人为划分输入区间
    - 对于一些因为变量之间存在依赖关系导致有效输入区域并不是一个各条棱相互正交的高维空间的软件，等价类测试可能会产生无效的甚至错误的测试用例
- 边界值测试与等价类测试的缝合怪：边缘测试
- 决策表测试
    - 适用于业务流复杂的软件
    - 提炼软件输入和输出的逻辑规则，对每一个条件组合（“规则”）做一个测试用例
    - 合并同类项，提取等价类，逐级分解决策表，改善条件表项设置，减少用例数量（这样做不会导致测试完备性损失！）
- 测试方法的选用原则 [PPT Ch5 P39]

## 第六节 结构化测试（白盒测试）

- 目的
    - 根据程序内部的逻辑结构验证软件的结构是否正确，要求实现较高的覆盖率
    - 单元测试大多采用白盒测试，系统测试大多采用黑盒测试
    - 白盒测试相比于黑盒测试善于发现内存泄漏，误差累积等系统内的隐患性的深层故障
- 代码逻辑的形式化
    - 程序图
        - 节点：不含分支和循环的代码片
        - 有向边：代码片执行的拓扑关系（控制流）
        - 缺陷：不同的代码分片粒度可能会导致一段代码可以产生多种程序图
    - DD (Decision-to-Decision) -路径图：程序图的唯一压缩图
        - DD-路径：程序图内的最小独立路径，互不包含
            - 源点 (入度 == 0)
            - 汇点 (出度 == 0)
            - 分支结点/汇合结点 (入度 >= 2 ^ 出度 >= 2)
            - 一个 (入度 == 1 && 出度 == 1) 的结点
            - 一串（ >= 2个） (入度 == 1 && 出度 == 1) 的结点构成的最大链
        - 节点：DD-路径
        - 边：DD-路径执行的拓扑关系（控制流）
- 路径测试：关注程序结构但不关心数据
    - 相关的测试覆盖指标
        - $C_0$：语句覆盖（DD-路径图的结点覆盖），测试用例集使得所有语句至少执行一次
        - $C_1$：分支覆盖（DD-路径图的边覆盖），使得每个判断表达式的真假各至少取到一次，且每个分支表达式的所有情况被遍历
        - $C_{1p}$：条件覆盖，使得每个判断表达式中的每个子句（谓词）的真假各至少取到一次（不能保证判断表达式的真假各取到一次！），且每个分支表达式的所有情况被遍历
        - $C_{mcc}$：使得每个判断表达式中的所有可能子句取值组合被遍历
        - $C_{\infty}$：路径覆盖，遍历所有可能的执行路径
        - $C_{ik}$：k-循环覆盖，覆盖包含至多 `k` 次循环的所有程序路径
        - $C_2$：$C_1$覆盖+$C_{i1}$覆盖
        - 分支-条件覆盖：分支覆盖和条件覆盖的缝合怪，和$C_{mcc}$的区别在于开销稍低
    - 循环测试的方法（假设循环执行 `N` 次）
        - 单循环测试：循环 `0, 1, 2, 某一中间值, N-1, N, N+1` 次
        - 嵌套循环测试：由内到外按单循环测试，测试某一层时其他层次循环次数为1
        - 级联循环测试：逐个按单循环测试
        - 不规则循环测试：不测，打回去重写（现实中这种情况可能由于不当使用 `try - catch` 语句等原因产生）
    - McCabe的基路径方法
        - McCabe基路径，圈复杂度，McCabe圈数 [概念转隔壁离散数学]
        - 圈复杂度类似于DD-路径图的“秩”
        - 圈复杂度主要用于衡量和帮助控制软件的复杂度
        - 找到所有的基本路径，只需测试所有基本路径便可以认为所有可能的执行路径都已被覆盖（因为它们都是基本路径的线性表示！）
        - 但是这种图论分析不考虑程序的语义，计算得到的基本路径实际上可能是不可达的
- 数据流测试
