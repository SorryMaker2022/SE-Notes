# 软件测试笔记

评分：小测 2 * 5 分，作业 4 * 10 分，开卷期末 50 分

[Slides: Course slides in `./slides`]

[Book: 软件测试：一个软件工艺师的方法（第四版），机械工业出版社]

## 第一节 概论

- 软件测试的必要性和重要性
    - 基本事实：各种各样的软件已经到处都是
    - 软件错误会带来巨大的潜在损失（直接损失和发现错误后的修复成本等）
    - 即使是优秀的程序员，即使有很好的系统设计，在绝大多数情况下都不是error-free的
    - 如何保障软件质量：除了提高代码质量，改善软件工程方法之外，做软件测试已经成为了主要的软件质量保障方法
- 软件测试的目的
    - 功能正确
    - 了解性能
    - 测试安全性
    - 测试易用性
    - 在完成以上几项的基础上尽量减小测试开销
- 基本概念
    - 测试用例（test case）：包含输入和期望输出
    - 错误（error）：底层的编程错误，错误很容易传播（propagate）
    - 故障（fault）：错误的具体表现，故障不一定是由编程错误引入的，也有可能是物理设备故障，系统设计错误和用户交互错误
    - 失效（failure）：代码运行时发生故障的后果，错误转为失效需要满足RIPR模型
        - 用状态图分析程序，当执行过一个故障时，程序的状态与期望的程序状态将出现差异
        - Reachability - 故障是可达的
        - Infection - 故障会导致代码状态出错
        - Propagation - 错误的状态会导致代码的最终状态或输出出错
        - Revealability - 最终状态错误或输出错误必须是可观察的
        - 可以用RIPR模型帮助设计测试用例
    - 事故（incident）：用户能够明确发现的失效
- 基本原则
    - Myers准则
        - 在软件开发的早期就开始测试，并持续测试
        - 避免开发者测试自己的软件
        - 测试用例不仅要包含输入，还要包含期望输出
        - 测试用例需要包涵有效输入和无效输入
        - 测试用例需要覆盖“软件该做什么”和“软件不该做什么”
        - 测试发现的错误和实际存在的错误的量成正比
        - 应当进行多轮反复测试
        - 软件测试是创新性的工作！
    - 独立性准则（第三方测试）
    - 完备性准则
        - 完成测试计划
        - 达成一定的覆盖率指标
- 基本过程
    - 设计测试计划
    - 生成测试用例
    - 搭建测试环境
    - 执行测试用例
    - 评估测试结果
- 一些其他事实
    - 可能的输入集合（在大部分情况下）是难以遍历的甚至无法遍历的，软件测试需要选出一些有价值的输入输出作为测试用例
    - 软件测试的开销是不可忽略的（事实上甚至往往超过软件总开发成本的一半！），软件测试工程常常要在测试开销和测试效果（测试覆盖率）之间做trade-off
    - 软件测试不能保证软件是error-free的，需要证明error-free请转隔壁形式化验证

## 第二节 数学基础

[出门转隔壁离散数学]

## 第三节 基本理论和基本方法

[Slides Ch3 P3]

- 静态测试
    - Code Review
    - 代码分析
    - 走查和审查
- 动态测试
    - 黑盒测试：针对需求规格说明进行检验
        - 边界值测试
        - 等价类测试
        - 决策表测试
    - 白盒测试：针对代码进行检验，路径导向
        - 路径测试
            - 语句覆盖
            - 路径覆盖
            - 判断覆盖
        - 数据流测试
- 形式化验证（开销极大，用于需要保证程序完全安全，error-free的场景，几乎不可能广泛使用）
- 其他测试方法 [Slides Ch3 P32 - P41]
    - 变异测试
    - 回归测试
    - 故障统计（标志重捕法）与可靠性分析
    - 净室法

## 第四节 测试环境和测试工具

- Java
    - JRE & JDK
    - 良好的测试环境和工具支持
- JUnit 回归测试框架
    - 适合于极限编程方法
    - Eclipse/Idea 对 JUnit 有良好的集成支持
    - 测试用注解 [Slides Ch4 P10]
    - JUnit 框架的测试流程
        - `setUp()` 创建测试实例
        - `testMethod()` 执行测试方法
        - `tearDown()` 回收实例资源
        - 注意：多个测试方法不应相互依赖（因为它们都在独立的实例中被测试）
- EMMA 覆盖率分析工具
- IntelliJ Idea
    - 丰富的内置工具和插件
    - 如何正确的代码结构与目录管理：将测试代码与主程序放置在不同的根目录下
    - 测试类的代码生成
    - 自动化生成测试报告
- 参数化测试工具：将测试用例与测试代码分离，简化多测试用例对应的代码
    - 工具：JUnit4/JUnit5/TestNG
- 打桩 (Mock) 测试：模拟对其他模块的调用，提高覆盖率，方便故障定位，去除模块间依赖
    - 工具：Mockito/PowerMock
- 变异测试：评估一组测试用例的完备性
    - 工具：Pitest
- 完善的测试文档案例 [Slides Ch4 P49 - P62] [Book Appendix]

## 第五节 功能性测试（黑盒测试）

- 目的
    - 按需求规格说明书对软件的外部特征进行测试，确认系统的功能是否正确实现
- 软件缺陷的基本假设
    - 单缺陷假设：失效很少是由两个或更多缺陷同时发生引起的
    - 多缺陷假设（“最坏情况”）：拒绝单缺陷假设，认为失效可能是由两个或更多缺陷同时发生引起的
    - 健壮性：考虑无效输入
- 边界值测试
    - 基本事实：很多函数更倾向于在边界值附近出错
    - 对一个有 n 个参数（即 n 个输入维度）的函数：
    - 划分出有效输入区域（一个 n 维空间）（为了讨论方便，假设每个输入维度上只有一个连续的有效输入区间）[Book Ch10 P133]
    - 边界值测试的几种类型：
        - 一般边界值测试：测试用例为保持其他维度取随机有效中间值，某一维度取最小值，略高于最小值，最大值，略低于最大值（对每个输入维度都要测试），再加上一个所有输入维度都取中间值的用例，共 4n + 1 个
        - 健壮性测试：测试用例在一般边界值测试的基础上对每个输入维度追加略低于最小值和略高于最大值的两个无效输入，将测试用例增加到 6n + 1 个
        - 最坏情况测试：拒绝单缺陷假设，考虑每一个输入维度的五种输入（最小值，略高于最小值，最大值，略低于最大值，中间值）的自由组合，测试用例数量共 $5^n$ 个
        - 健壮最坏情况测试：在最坏情况测试的基础上考虑每个输入维度的略低于最小值和略高于最大值的两个无效输入，将测试用例增加到 $7^n$ 个
    - 一般边界值测试和健壮性测试的开销对输入维度数量是线性的，最坏情况测试的开销对输入维度数量是指数的
- 随机测试
    - 随机取出测试用例，直到满足一定的测试需求再停止（例如每类输出至少有一个，或每类输入至少有5个等）
- 特殊值测试
    - 直接凭借测试者的背景知识产生“可能”揭示故障的测试用例
- 等价类测试
    - 对一个有 n 个参数（即 n 个输入维度）的函数：
    - 按一定标准生成每个输入维度的一个划分（一组并是全集的不相交集），即等价区间
    - 不妨假设第 i 个输入维度的等价区间数量为 $m_i$
    - 等价类测试的几种类型：
        - 弱一般等价类测试：取等同于等价区间数量最多的输入维度的等价区间数量的测试用例数量，即 $max(m_i)$ 个 ，保证每一个输入维度的每一个等价区间都被取到至少一次（输入在等价区间内的取值是随机的），这种方法对错误定位存在局限性
        - 强一般等价类测试：拒绝单缺陷假设，覆盖所有的等价区间组合，测试用例共 $\prod m_i$ 个
        - 弱健壮等价类测试：对每个输入维度考虑无效输入的等价区间，不妨假设第 i 个输入维度的无效输入等价区间数量为 $p_i$ 个（一般若无特殊说明则认为 $p_i = 2$ ，则取 $[max(m_i + p_i), max(m_i) + \sum p_i]$ 个测试用例（“弱健壮等价类测试”～“改进弱健壮等价类测试”），取法同弱一般等价类测试
        - 强健壮等价类测试：覆盖所有包含无效输入的等价区间组合，将测试用例增加到 $\prod (m_i + p_i)$ 个
    - 等价区间的划分不一定要有实际的应用场景意义，也可以直接按照输出类型划分或者人为划分输入区间
    - 对于一些因为变量之间存在依赖关系导致有效输入区域并不是一个各条棱相互正交的高维空间的软件，等价类测试可能会产生无效的甚至错误的测试用例
- 边界值测试与等价类测试的缝合怪：边缘测试
- 决策表测试
    - 适用于业务流复杂的软件
    - 提炼软件输入和输出的逻辑规则，对每一个条件组合（“规则”）做一个测试用例
    - 合并同类项，提取等价类，逐级分解决策表，改善条件表项设置，减少用例数量（这样做不会导致测试完备性损失！）
- 测试方法的选用原则 [Slides Ch5 P39]

## 第六节 第七节 结构化测试（白盒测试）

- 目的
    - 根据程序内部的逻辑结构验证软件的结构是否正确，要求实现较高的覆盖率
    - 单元测试大多采用白盒测试，系统测试大多采用黑盒测试
    - 白盒测试相比于黑盒测试善于发现内存泄漏，误差累积等系统内的隐患性的深层故障
- 代码逻辑的形式化
    - 程序图
        - 节点：不含分支和循环的代码片
        - 有向边：代码片执行的拓扑关系（控制流）
        - 缺陷：不同的代码分片粒度可能会导致一段代码可以产生多种程序图
    - DD (Decision-to-Decision) -路径图：程序图的唯一压缩图
        - DD-路径：程序图内的最小独立路径，互不包含
            - 源点 (入度 == 0)
            - 汇点 (出度 == 0)
            - 分支结点/汇合结点 (入度 >= 2 ^ 出度 >= 2)
            - 一个 (入度 == 1 && 出度 == 1) 的结点
            - 一串（ >= 2个） (入度 == 1 && 出度 == 1) 的结点构成的最大链
        - 节点：DD-路径
        - 边：DD-路径执行的拓扑关系（控制流）
- 路径测试：关注程序结构但不关心数据
    - 相关的测试覆盖指标
        - $C_0$：语句覆盖（DD-路径图的结点覆盖），测试用例集使得所有语句至少执行一次
        - $C_1$：分支覆盖（DD-路径图的边覆盖），使得每个判断表达式的真假各至少取到一次，且每个分支表达式的所有情况被遍历
        - $C_{1p}$：条件覆盖，使得每个判断表达式中的每个子句（谓词）的真假各至少取到一次（不能保证判断表达式的真假各取到一次！），且每个分支表达式的所有情况被遍历
        - $C_{mcc}$：多重条件覆盖（组合覆盖），使得每个判断表达式中的所有可能子句取值组合被遍历
        - $C_{\infty}$：路径覆盖，遍历所有可能的执行路径
        - $C_{ik}$：k-循环覆盖，覆盖包含至多 k 次循环的所有程序路径
        - $C_2$： $C_1$ 覆盖+ $C_{i1}$ 覆盖
        - 分支-条件覆盖：分支覆盖和条件覆盖的缝合怪，开销比 $C_{mcc}$ 低
    - 循环测试的方法（假设循环执行 N 次）
        - 单循环测试：执行循环体 0, 1, 2, 某一中间值, N-1, N, N+1 次（类似于健壮边界值测试）
        - 嵌套循环测试：由内到外按单循环测试，测试某一层时其他层次循环次数为1
        - 级联循环测试：逐个按单循环测试
        - 不规则循环测试：不测，测不了，打回去重构（现实中这种情况可能由于不当使用 try - catch 语句等原因产生）
    - McCabe的基路径（基本路径）方法
        - McCabe基路径，圈复杂度，McCabe圈数 [概念转隔壁离散数学]
        - 圈复杂度类似于DD-路径图的“秩”
        - 圈复杂度主要用于衡量和帮助控制软件的复杂度
        - 基本路径类似于向量空间中的基向量
        - 找到所有的基本路径，只需测试所有基本路径便可以认为所有可能的执行路径都已被覆盖（因为它们都是基本路径的线性表示！）
        - 但是这种图论分析不考虑程序的语义（线性表示的拓扑语义是模糊的），计算得到的基本路径实际上可能是不可达的
- 数据流测试
    - 通过编译器静态排查简单的故障
    - 定义-使用 (def-use) 测试
        - 定义节点，使用节点，谓词使用和计算使用
        - 定义使用路径 (du-path) 和定义清除路径 (dc-path)
        - 相关的测试覆盖指标（假设所有拓扑路径都是可达的）
            - 全节点覆盖，全边覆盖，全路径覆盖：同语句覆盖，分支覆盖，路径覆盖
            - 全定义覆盖：覆盖每个定义节点到一个使用节点的定义清除路径
            - 全谓词使用/部分计算使用：覆盖每个定义节点到所有谓词使用（如无，则改为到一个计算使用）的定义清除路径
            - 全计算使用/部分谓词使用：覆盖每个定义节点到所有计算使用（如无，则改为到一个谓词使用）的定义清除路径
            - 全使用覆盖：每个定义节点到所有使用节点及其后续节点的定义清除路径
            - 全定义-使用路径覆盖：覆盖每个定义节点到所有使用节点及其后续节点的定义清除路径，如果包含循环，测试不循环和循环一次这两种情况
        - 关注数据使用的正确性，但忽视了数据间的依赖关系
- 程序片测试
    - 程序中某个变量集合的程序片是对这些变量值“有贡献”（不仅是直接的定义，还可以是因谓词使用等因素对当前关注的变量值产生影响）的所有语句（静态后向切片）的集合
    - 程序切片的前向，后向，静态，动态 [Book Ch9 P116] [Link: https://blog.csdn.net/hmysn/article/details/124717162#t6]
    - 每次测试某一个变量集合的切片是否正确（如果这个变量集合的所有子集（包含本身）的程序片测试结果都是正确的，就认为这个变量集合的切片是正确的），如果所有变量（变量的全集）的定义和使用都是正确的就可以认为程序整体是正确的
    - 能够细致地反应数据间的依赖关系
    - 能够比较便捷地定位错误（通过不同程序片的对比快速找出错误位置）

- 单元测试的总结
    - 何时结束测试？ [Slides Ch7 P57] [Book Ch10 P126]
    - 测试方法的取舍：trade-off
    - 对测试的评估：漏洞与冗余
        - 量化指标：假设执行方法 M 生成的 m 个测试用例时经过了测试指标 S 所指出的 s 个结构性测试单元中的 n 个，则：
            - M关于S的覆盖 $C (M, S) = \dfrac{n}{s}$
            - M关于S的冗余 $R (M, S) = \dfrac{m}{s}$
            - M关于S的净冗余 $NR (M, S) = \dfrac{m}{n}$
    - 测试的指导方针 [Βοοk Ch10 P138]

## 小测（25分钟/5道简答题，范围到路径测试）

## 第八节 基于生命周期的测试

- 一个问题：如何从单元测试拓展到对整个软件的测试？
    - “王源”（传统）的观点：瀑布式生命周期管理
        - 虽然有些古老，但也不失可取之处：便于管理，分工明确，便于并行工作
        - 存在的问题：不够灵活，要求开发者对整个系统的完整理解，软件工程风险全部落在最后阶段
        - 瀑布模型的变体
            - 增量开发模型：多次提交，不断追加功能，但需要预留一个开放的软件体系结构以便追加功能
            - 演化开发（快速原型）模型：反复提供原型软件，有助于明确客户需求，但设计大量原型比较困难（一般是利用现有的软件原型）
            - 螺旋模型：在瀑布模型的基础上对每个阶段都增加风险分析与验证的步骤，可以保证项目的可控性，但对软件风险评估提出了更高的要求
            - 核心思想是强调迭代与集成而非功能分解，从而将软件工程风险分散到软件工程过程中以便进行风险控制
            - 适合使用回归测试
        - 软件测试的V-层次模型
            - 单元测试：面向详细设计的对软件独立模块的测试
            - 集成测试：面向概要设计的对软件模块之间的组合的测试
            - 系统测试：面向需求分析的对系统功能的测试
    - “顶针”（现代）的观点：敏捷开发
        - 一个很大的范畴
            - Scrum [Slides Ch8 P14]
                - 测试位于每次冲刺后
            - 极限编程 (XP) [Slides Ch8 P15 - P34]
                - 每次迭代都有测试
            - 测试驱动 (TDD)
            - 适应性软件开发
            - 结对编程等
        - 敏捷宣言：核心是以人为本，适应变化
            - 个体和交互胜过过程和工具
            - 可用的软件胜过完备的文档（但是不能0文档！）
            - 客户协作胜过合同谈判
            - 响应变化胜过遵循计划
